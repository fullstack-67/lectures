---
marp: true
theme: default
class:
  - invert
author: Nirand Pisutha-Arnond
paginate: true
footer: "261497: Fullstack Development"
---

<style>
@import url('https://fonts.googleapis.com/css2?family=Prompt:ital,wght@0,100;0,300;0,400;0,700;1,100;1,300;1,400;1,700&display=swap');

    :root {
    font-family: Prompt;
    --hl-color: #D57E7E;
}
h1 {
  font-family: Prompt
}
</style>

# Fullstack Development

---

# Data Fetching in React (SPA)

---

# Method 1: `useEffect` Way

---

# Setup

- `git clone -b useeffect https://github.com/fullstack-67/df-http.git df-http`
- `git checkout -t origin/useeffect`

### Backend

- `cd backend`
- `pnpm i`
- `npm run dev`

---

# Setup

### Frontend

- `cd frontend`
- `pnpm i`
- `npm run dev`

---

# Layout

![width:800px](./img/df_arch.png)

---

`./src/components/Clock.tsx`

```ts
const Clock: FC<Props> = () => {
  const [clock, setClock] = useState("");
  const refetch = () => {
    // Fetching logic
  };
  useEffect(() => {
    refetch();
  }, []);
  // return JSX
};
```

---

# `useEffect`

- `Good`
  - No external library required
- `Bad`
  - Confusing to write
- `Comment`
  - States are all local.

---

# Method 2: `useEffect` + Custom hook

---

# Setup

- `git checkout -t origin/custom-hook`

---

`./src/hooks/useClock.ts`

```ts
function useClock() {
  const [clock, setClock] = useState("");
  const refetch = () => {
    // Fetching logic
  };
  useEffect(() => {
    refetch();
  }, []);

  return { clock, refetch };
}
```

---

# `useEffect` + Custom hook

- `Good`

  - Logic encapsulation
  - Cleaner components

- `Comment`
  - States are still all local.

---

# Method 3: `useEffect` + Prop drilling

---

# Prop drilling

![bg right:60% contain](./img/df_prop_drilling.png)

---

# `useEffect` + Prop drilling

- `Good`
  - No external library required
  - Pure components
- `Bad`
  - Impractical for deep-nested components.
  - Fetching logic is too "far" from the view (JSX).

---

# Method 4: `useEffect` + Global store

---

# Global store pattern

What does using a global store solve?

- Multiple copies of states
- Prop drilling
- Unncessary re-render

---

![width:800px](./img/store.png)

---

# Global store libraries / API

- `React Context`
- `Redux`
- `Jotai`
- `Zustand`

---

# React Context

- Native API
- Fine, but...

---

```ts
const App = () => {
  // ... some code
  return (
    <>
      <ReduxProvider value={store}>
        <ThemeProvider value={theme}>
          <OtherProvider value={otherValue}>
            <OtherOtherProvider value={otherOtherValue}>
              {/** ... other providers*/}
              <HellProvider value={hell}>
                <HelloWorld />
              </HellProvider>
              {/** ... other providers*/}
            </OtherOtherProvider>
          </OtherProvider>
        </ThemeProvider>
      </ReduxProvider>
    </>
  );
};
```

---

# Redux

- Powerful
- Has Redux Dev Tool
- Can be used standalone
- Too much boiler plate for small projects

---

![width:800px](./img/redux1.jpg)

---

## ![width:800px](./img/redux2.jpg)

---

# Zustand

- Minimalist
- Use Redux-style (flux principle)
- No provider

# Jotai

- Another cool library but I never used it.

---

# Setup

- `git checkout -t origin/zustand`
- `pnpm i`

---

# Store

`./src/stores/useGlobalStore.ts`

```ts
import { create } from "zustand";

interface Store {
  clock: string;
  setClock: (c: string) => void;
}

const useGlobalStore = create<Store>((set) => ({
  clock: "",
  setClock: (c) => set(() => ({ clock: c })),
}));
```

---

`./src/components/Clock.tsx`

```ts
import useGlobalStore from "../stores/useGlobalStore";

const Clock: FC<Props> = () => {
  // No useState now
  const [clock, setClock] = useGlobalStore((state) => [
    state.clock,
    state.setClock,
  ]);
  const refetch = () => {
    // Fetching logic
  };
  useEffect(() => {
    if (initialFetch) refetch();
  }, []);

  // return JSX
};
```

---

# `useEffect` + Global store

- `Good`
  - Shared state.
  - Less network requests
- `Bad`
  - Not pure components

---

# Method 5: React Query + Custom hook

---

# Reach Query

- Data-fetching + state management library
- Highly recommended!

---

# Setup

- `git checkout -t origin/react-query`
- `pnpm i`

---

# Provider

`./src/main.tsx`

```ts
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

// Create a client
const queryClient = new QueryClient();

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
      <ReactQueryDevtools initialIsOpen={false} />
  </StrictMode>
);
```

---

`./src/hooks/useClock.ts`

```ts
import { useQuery } from "@tanstack/react-query";

function getClock() {
  // Return promise
}

function useClock() {
  const query = useQuery({
    // Options
  });

  return { clock: query.data ?? "", refetch: query.refetch };
}

export default useClock;
```

---

# Note

- Try inspect `query` object.
- Try navigate away and refocus the tab.
- Try option `refetchInterval`
- Try using the dev tool.

---

# React Query + Custom hook

- `Good`
  - Do I have to repeat myself?
- `Bad`
  - A little bit of setup / learning curve
- `Note`
  - Use it please.
